## CCC Junior 2025 Solutions: Complete Python Walkthrough  

#### Written at Apr 13, 2025  

> *"Code like youâ€™re explaining it to your future self."*  
> â€“ CCC mindset ðŸš€  


### Competition Overview  
The 2025 Canadian Computing Competition (Junior) featured five problems spanning core concepts: basic calculations, loop logic, sorting, string analysis, and grid traversal. Each problem tests not just coding skills, but the ability to break down real-world scenarios into logical steps.  


---

### J1: Fruit Stand Calculation  

#### Problem Statement  
A fruit stand sells apples for \$2, bananas for \$1, and oranges for \$3. Given the number of each fruit purchased (`A, B, O`), compute the total cost. Input three non-negative integers, output the total.  

#### Solution Approach  
1. Read the three integers `A` (apples), `B` (bananas), `O` (oranges).  
2. Calculate total cost using the formula: `A*2 + B*1 + O*3`.  
3. Print the result.  

```python
def j1_solution():
    A = int(input().strip())
    B = int(input().strip())
    O = int(input().strip())
    return A * 2 + B * 1 + O * 3

print(j1_solution())
```  

**Key Points:** Straightforward arithmeticâ€”focus on reading inputs correctly and avoiding calculation typos.  


---

### J2: Coin Collector  

#### Problem Statement  
Lila starts with 10 coins. She collects coins one by one; if a coinâ€™s value is less than her current total, she adds it to her total. If the coinâ€™s value is greater than or equal to her current total, she stops. Input ends when she canâ€™t collect the next coin. Output her final total.  

#### Solution Approach  
1. Read Lilaâ€™s initial total (fixed at 10).  
2. Continuously read coin values from input.  
3. For each coin: if its value < current total, add it to the total; else, stop.  
4. Output the final total.  

```python
def j2_solution():
    import sys
    data = list(map(int, sys.stdin.read().split()))
    total = 10  # Initial coins
    for coin in data:
        if coin >= total:
            break
        total += coin
    return total

print(j2_solution())
```  

**Key Points:** Use a loop to process input dynamically (since input length is unknown). Remember to break early when the condition is met.  


---

### J3: Coldest Days  

#### Problem Statement  
Given `N` daily temperatures (in Â°C, ranging from -50 to 50) with at least 3 distinct values, find the **second-lowest temperature** and count how many days had this temperature.  

#### Solution Approach  
1. Read `N` followed by the list of temperatures.  
2. Extract unique temperatures, sort them in ascending order.  
3. The second-lowest temperature is the 1st index in the sorted unique list (since indexes start at 0).  
4. Count how many times this temperature appears in the original list.  

```python
def j3_solution():
    N = int(input().strip())
    temps = [int(input().strip()) for _ in range(N)]
    unique_sorted = sorted(set(temps))  # Sort unique temps ascending
    second_lowest = unique_sorted[1]
    count = temps.count(second_lowest)
    print(second_lowest, count)

j3_solution()
```  

**Key Points:** Use `set()` to remove duplicates, then sort. Counting is efficient with the `list.count()` method.  


---

### J4: Typo Tracker  

#### Problem Statement  
A keyboard has a **faulty key** (always types a specific wrong character) and optionally a **muted key** (types nothing). Given the original text typed (`typed`) and the displayed text (`shown`), identify:  
- The faulty key and the character it incorrectly outputs.  
- The muted key (if any; output `-` if none).  

#### Solution Approach  
1. Read `typed` and `shown` strings.  
2. Use frequency counters to compare character counts in both strings.  
3. **Faulty key**: Appears more in `typed` than in `shown` (since itâ€™s replaced by another character).  
4. **Incorrect output**: The character that appears more in `shown` than in `typed` (the replacement for the faulty key).  
5. **Muted key**: Appears in `typed` but is missing/underrepresented in `shown`, and isnâ€™t the faulty key.  

```python
def j4_solution():
    from collections import Counter
    typed = input().strip()
    shown = input().strip()
    cnt_typed = Counter(typed)
    cnt_shown = Counter(shown)
    
    # Find faulty key (excess in typed) and its wrong output (excess in shown)
    faulty = None
    wrong = None
    for char in cnt_typed:
        if cnt_typed[char] > cnt_shown.get(char, 0):
            faulty = char
            break
    for char in cnt_shown:
        if cnt_shown[char] > cnt_typed.get(char, 0):
            wrong = char
            break
    
    # Find muted key (excess in typed but not faulty)
    muted = '-'
    if len(typed) > len(shown):
        for char in cnt_typed:
            if char != faulty and cnt_typed[char] > cnt_shown.get(char, 0):
                muted = char
                break
    
    print(faulty, wrong)
    print(muted)

j4_solution()
```  

**Key Points:** Frequency analysis simplifies the problemâ€”focus on identifying "excess" characters in each string.  


---

### J5: Gem Hunter  

#### Problem Statement  
On a `RÃ—C` grid, cells contain gems: `C`=2 points, `D`=7 points, `E`=15 points, or rocks (`#`). Starting from position `(X, Y)` (1-based index), move 4-directionally (up, down, left, right) without revisiting cells or crossing rocks. Sum the values of all reachable gems.  

#### Solution Approach  
1. Read grid dimensions `R, C`, the grid itself, and start coordinates `(X, Y)` (convert to 0-based for easier indexing).  
2. Use BFS (Breadth-First Search) to explore all reachable cells from the start:  
   - Track visited cells to avoid loops.  
   - Skip rocks and cells outside grid bounds.  
3. Accumulate gem values (`C=2`, `D=7`, `E=15`) as you traverse.  
4. Output the total.  

```python
def j5_solution():
    from collections import deque
    R = int(input())
    C = int(input())
    grid = [input().strip() for _ in range(R)]
    X, Y = map(int, input().split())
    # Convert to 0-based index
    start_r, start_c = X - 1, Y - 1
    
    gem_values = {'C': 2, 'D': 7, 'E': 15}
    visited = [[False for _ in range(C)] for _ in range(R)]
    total = 0
    
    # BFS setup
    q = deque()
    q.append((start_r, start_c))
    visited[start_r][start_c] = True
    
    # Directions: up, down, left, right
    dirs = [(-1, 0), (1, 0), (0, -1), (0, 1)]
    
    while q:
        r, c = q.popleft()
        # Add gem value if current cell is a gem
        if grid[r][c] in gem_values:
            total += gem_values[grid[r][c]]
        # Explore neighbors
        for dr, dc in dirs:
            nr, nc = r + dr, c + dc
            # Check bounds and if not visited/rock
            if 0 <= nr < R and 0 <= nc < C:
                if not visited[nr][nc] and grid[nr][nc] != '#':
                    visited[nr][nc] = True
                    q.append((nr, nc))
    
    return total

print(j5_solution())
```  

**Key Points:** BFS is ideal for grid traversal (avoids recursion limits). Always track visited cells to prevent infinite loops.  


---

## Competition Strategy Guide  

**How to ace CCC Junior 2025:**  

1. **Prioritize J1â€“J2 first:** These are designed to be quick winsâ€”solve them first to build momentum.  
2. **Handle unknown input lengths:** Use `sys.stdin.read()` (as in J2) to read all input at once when the number of values isnâ€™t specified.  
3. **Leverage built-in functions:** `sorted()`, `set()`, and `Counter` (from `collections`) simplify sorting, deduplication, and frequency tasks (J3, J4).  
4. **Grid traversal tips:** For J5, BFS is safer than DFS for large grids (avoids stack overflow). Always convert 1-based to 0-based indices!  
5. **Test edge cases:** What if all coins are too big (J2)? What if thereâ€™s no muted key (J4)? Anticipating these avoids bugs.  


> *The best code is simple, clear, and solves the problem.* Keep coding, keep learning, and next yearâ€™s CCC will be even easier. ðŸ’»ðŸŒŸ