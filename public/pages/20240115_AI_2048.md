## Teaching AI Through Game, Long time no see 2048

#### Written at Jan 15, 2024

Last semester, I was tasked with preparing a lecture on programming and AI for high school seniors about to enter college. Staring at a blank slide deck, I felt stuckâ€”how do you make AI approachable to students who might have only heard the term in passing? Theories felt too abstract, and generic examples seemed uninspiring. Thatâ€™s when a memory from my UCSD undergrad days in CSE150B popped into my head: our final project, where we built an AI to play 2048 using the Minimax algorithm.

"Perfect," I thought. 2048 is a puzzle game almost everyone recognizesâ€”simple rules, satisfying gameplay, but with enough depth to showcase real AI decision-making. By building the game from scratch in Python and then teaching an AI to play it, I could bridge "basic programming" and "intelligent systems" in a single demo.

### From Lecture Idea to Working Demo

I dug up my old project files and refactored the core logic to make it beginner-friendly. First, I recreated the 2048 game mechanics using Pygameâ€”clean, visual, and easy to follow. Then, I implemented the Minimax algorithm to let the AI "think" through moves: simulating future states, evaluating board quality, and choosing the optimal path. Watching the tiles auto-merge toward 2048 during testing brought back memories of debugging evaluation functions in the CSE150B labâ€”frustrating then, but perfect for a demo now.

The lecture exceeded all expectations. When I switched from manual play to AI mode, the room eruptedâ€”students leaned forward, asking how the program "knew" which move was best, how the scoring worked, and if they could try modifying the code. By the end, a crowd gathered around my laptop, scribbling notes on the core functions. "Can you share this?" became the most frequent question.

This post is my answer to themâ€”and to anyone curious about how AI meets everyday games.


## ðŸŽ® The 2048 Foundation: Building the Game

Letâ€™s start with the game itself. I built a Pygame-based 2048 clone with all the classic features, designed to be easy to understand and modify.

### Key Features

- Classic 2048 gameplay (tile merging, score tracking)
- Smooth rendering with dynamic font sizes (adjusts for larger numbers)
- Interactive UI with restart/continue buttons (with hover effects)
- Support for both keyboard (arrow keys) and mouse input
- Clean, responsive design with color-coded tiles


### Project Structure

The code is split into two main files for clarity:

```
2048_AI/
â”œâ”€â”€ assets/               # Button icons
â”‚   â”œâ”€â”€ restart.png
â”‚   â””â”€â”€ continue.png
â”œâ”€â”€ main.py               # Core game logic (Game2048 class)
â”œâ”€â”€ utils.py              # Constants (sizes, colors, fonts)
â””â”€â”€ README.md             # Setup instructions
```


### Core Game Logic

The `Game2048` class in `main.py` handles everything from rendering to tile movement. Letâ€™s break down its key parts.

#### Initialization

We start by setting up the game window, fonts, and initial grid (with two random tilesâ€”2 or 4):

```python
class Game2048:
    def __init__(self):
        self.width = WIDTH  # From utils.py
        self.height = HEIGHT
        self.screen = pygame.display.set_mode((WIDTH, HEIGHT))
        pygame.display.set_caption("2048")

        # Fonts and scoring
        self.font = pygame.font.SysFont("Arial", FONT_SIZE, bold=True)
        self.score = 0
        self.best_score = 0
        
        # 4x4 grid (GRID_SIZE from utils.py)
        self.grid = [[0 for _ in range(GRID_SIZE)] for _ in range(GRID_SIZE)]
        self.add_new_tile()  # Spawn first tile
        self.add_new_tile()  # Spawn second tile
```


#### Tile Movement & Merging

The most critical part is handling tile movement (via arrow keys) and merging. The `move` method processes directions, while `merge_row` handles the logic for combining tiles:

```python
def move(self, direction):
    if self.game_over:
        return False

    moved = False
    if direction == "left":
        for i in range(GRID_SIZE):
            row, did_move = self.merge_row(self.grid[i])
            self.grid[i] = row
            moved |= did_move
    # Similar logic for right/up/down (omitted for brevity)

    if moved:
        self.add_new_tile()  # Spawn new tile after valid move
        self.check_game_state()  # Check for win/lose
    return moved

def merge_row(self, row):
    # Remove empty spaces first
    new = [i for i in row if i != 0]
    new += [0] * (GRID_SIZE - len(new))
    merged = []
    skip = False
    moved = False

    # Merge adjacent equal tiles
    for i in range(len(new)):
        if skip:
            skip = False
            continue
        if i < len(new) - 1 and new[i] == new[i + 1]:
            merged.append(new[i] * 2)
            self.score += new[i] * 2  # Update score on merge
            skip = True
            moved = True
        else:
            merged.append(new[i])
    merged += [0] * (GRID_SIZE - len(merged))
    return merged, moved
```


#### Visuals & UI

The `draw` method renders everythingâ€”grid, tiles, score, and buttons. Tiles use color coding from `utils.py` (e.g., 2 is light beige, 2048 is bright yellow):

```python
def draw(self):
    self.screen.fill(BACKGROUND_COLOR)  # From utils.py

    # Draw title and score panel
    title_text = self.large_font.render("2048", True, TEXT_COLOR)
    self.screen.blit(title_text, (20, 20))

    # Render tiles with dynamic colors
    for i in range(GRID_SIZE):
        for j in range(GRID_SIZE):
            val = self.grid[i][j]
            x = start_x + GRID_PADDING + j * (TILE_SIZE + GRID_PADDING)
            y = start_y + GRID_PADDING + i * (TILE_SIZE + GRID_PADDING)

            # Use predefined colors (utils.py)
            pygame.draw.rect(
                self.screen,
                TILE_COLORS.get(val, TILE_COLORS[0]),  # e.g., 2 â†’ (238, 228, 218)
                (x, y, TILE_SIZE, TILE_SIZE),
                border_radius=4,
            )

            # Adjust font size for large numbers
            if val != 0:
                font = self.font if val < 100 else pygame.font.SysFont("Arial", FONT_SIZE - 8, bold=True)
                text = font.render(str(val), True, TEXT_COLORS.get(val, TEXT_COLOR))
                self.screen.blit(text, text.get_rect(center=(x + TILE_SIZE//2, y + TILE_SIZE//2)))
```


### ðŸš€ How to Run It

1. **Prerequisites**: Python 3.7+ and Pygame.
2. **Install dependencies**:
   ```bash
   pip install pygame
   ```
3. **Clone and run**:
   ```bash
   git clone [repository-url]
   cd 2048_AI
   python main.py
   ```

Controls:
- Arrow keys to move tiles
- "Restart" button to reset the game
- "Continue" button (appears after reaching 2048) to keep playing


## ðŸ¤– The AI Part: Minimax in Action

The real magic for the lecture was adding an AI player using the Minimax algorithm. Hereâ€™s the high-level idea:

- **Minimax**: A decision-making algorithm where the AI (maximizer) tries to maximize its score, while assuming the "game" (minimizer) will spawn the worst possible new tiles (e.g., a 4 in a bad position).
- **Evaluation Function**: Rates board quality based on factors like:
  - Total score
  - Number of empty tiles (more = better)
  - Monotonicity (tiles increasing/decreasing in a direction, easier to merge)
  - Smoothness (similar adjacent values)

During the lecture, I showed how tweaking the evaluation function drastically changes the AIâ€™s performanceâ€”perfect for demonstrating how "intelligence" in code is often just clever scoring.


## ðŸ“„ License

This project is licensed under the MIT Licenseâ€”feel free to modify and share!


## ðŸ”® Next Steps

For students looking to experiment:
1. Add animations for tile movement (try Pygameâ€™s `pygame.transform`).
2. Improve the AI with alpha-beta pruning (to speed up Minimax).
3. Add save/load functionality (using `pickle` or JSON).

Whether youâ€™re a soon-to-be freshman or just curious about AI, this project shows that even "smart" programs start with simple building blocks. Download the code, break things, and see what you can createâ€”thatâ€™s how real learning happens.

Happy coding!

The code could be found in https://github.com/YushanWang9801/2048_AI  and the branch CSE-158 was my original undergraduate work.